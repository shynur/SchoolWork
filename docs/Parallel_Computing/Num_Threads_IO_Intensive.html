<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
<!-- 2023-12-16 周六 21:41 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>并行 I​/​O 密集型任务的最佳线程数</title>
<meta name="author" content="[[https://github.com/shynur][/谢骐/]]" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<style> table, th, td {border: 1px solid;} code {box-sizing: border-box; background-color: #F3F5F9; color: #0ABF5B;} </style>
<script>
  window.MathJax = {
    tex: {
      ams: {
        multlineWidth: '85%'
      },
      tags: 'ams',
      tagSide: 'right',
      tagIndent: '.8em'
    },
    chtml: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    svg: {
      scale: 1.0,
      displayAlign: 'center',
      displayIndent: '0em'
    },
    output: {
      font: 'mathjax-modern',
      displayOverflow: 'overflow'
    }
  };
</script>

<script
  id="MathJax-script"
  async
  src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
</script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">并行 I​/​O 密集型任务的最佳线程数</h1>
<div id="table-of-contents" role="doc-toc">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgb45ab15">1. 引言</a></li>
<li><a href="#org8a5d770">2. 技术与理论背景</a>
<ul>
<li><a href="#orgfcf414e">2.1. CPU 与磁盘的性能对比</a>
<ul>
<li><a href="#org14d88ef">2.1.1. 速度与吞吐量</a></li>
<li><a href="#org594fe67">2.1.2. 并行处理能力</a></li>
</ul>
</li>
<li><a href="#orgcb46b9d">2.2. OpenMP 多线程机制</a>
<ul>
<li><a href="#orgf10dc5d">2.2.1. 并行模式</a></li>
<li><a href="#orga520f70">2.2.2. 编程模型</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org9afa006">3. 实验设计与结果</a>
<ul>
<li><a href="#orgf84db9f">3.1. 环境配置</a></li>
<li><a href="#orgf02037b">3.2. 设计思路</a></li>
<li><a href="#org5206c17">3.3. 代码</a></li>
<li><a href="#orgc584ec8">3.4. 测试</a></li>
</ul>
</li>
<li><a href="#org0a70bea">4. 数据分析</a>
<ul>
<li><a href="#org6b472a6">4.1. 性能上升区间</a></li>
<li><a href="#org445d11a">4.2. 最佳线程数</a></li>
<li><a href="#org1cb6cfd">4.3. 归因分析</a></li>
</ul>
</li>
<li><a href="#orgec29a4d">5. 结论与建议</a>
<ul>
<li><a href="#orgbc6c438">5.1. 经验法则的适用性</a></li>
<li><a href="#org3dfefbb">5.2. 实验的局限性</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>

</p>
<div id="outline-container-orgb45ab15" class="outline-2">
<h2 id="orgb45ab15"><span class="section-number-2">1.</span> 引言</h2>
<div class="outline-text-2" id="text-1">
<p>
在现代计算中, 高效处理大量小文件的读写操作是一个关键挑战, 特别是对于 I​/​O 密集型任务.
这些任务的性能不仅受 CPU 限制, 还受磁盘 I​/​O 的影响.
</p>

<p>
在 <a href="https://shop.fsf.org/books-docs/introduction-command-line"><i>Introduction to the Command Line</i></a><sup><a id="fnr.1" class="footref" href="#fn.1" role="doc-backlink">1</a></sup> 一书中提到:
</p>

<blockquote>
<p>
If you have several processors or processor cores, you can use multiple jobs to speed up processing by adding a <code>-j</code> option:
</p>

<div class="org-src-container">
<pre class="src src-bash">$ make -j3
</pre>
</div>

<p>
&hellip; &hellip;
</p>

<p>
&hellip;, <code>-j3</code> tells <code>make</code> to try to run \( 3 \) compilation processes simultaneously, which will allow you to utilize processor resources better if you have a dual-core or bigger machine.
The number after <code>-j</code> is arbitrary, but a good rule of thumb is <b>the number of processor cores plus one</b>.
</p>
</blockquote>

<p>
I.e., <a id="org9621aa6"></a> <span class="underline">对于​<i>可并行的 I​/​O 密集型任务</i>, 使用的​<b>线程数应该超过处理器核心数</b>​.</span>
</p>

<p>
本研究旨在通过实验验证这一<a href="#org9621aa6">经验法则</a>.
通过 C++ 调用 OpenMP, 在多种线程配置下执行基准测试, 探究线程数量对大量小文件磁盘 I​/​O 操作性能的影响, 以求取 I​/​O 密集型任务的最佳线程数目, 指导性能优化的实践.
</p>
</div>
</div>

<div id="outline-container-org8a5d770" class="outline-2">
<h2 id="org8a5d770"><span class="section-number-2">2.</span> 技术与理论背景</h2>
<div class="outline-text-2" id="text-2">
<p>
本章节将简要介绍与研究直接相关的技术和理论基础.
这​<i>可能</i>​从理论上证明<a href="#orgb45ab15">引言</a>中<a href="#org9621aa6">经验法则</a>的正确性, 并指导后续的<a href="#orgf02037b">实验方案的设计</a>.
</p>
</div>

<div id="outline-container-orgfcf414e" class="outline-3">
<h3 id="orgfcf414e"><span class="section-number-3">2.1.</span> CPU 与磁盘的性能对比</h3>
<div class="outline-text-3" id="text-2-1">
<p>
在处理可并行的 I​/​O 密集型任务时, 理解 CPU 和 磁盘 I​/​O 之间的性能差异至关重要.
差异主要体现在
</p>

<ul class="org-ul">
<li>处理速度</li>
<li>数据吞吐量</li>
<li>并行处理能力</li>
</ul>

<p>
这三个方面.
</p>

<p>
简而言之,
</p>

<div class="org-center">
<p>
CPU 在处理数据和并行能力上远超磁盘, 导致在 I​/​O 密集型任务中, 磁盘读写的性能成为了系统的瓶颈.
</p>
</div>

<p>
因此, 合理地利用线程​<span class="underline">在等待 CPU 与磁盘之间的 I​/​O 处理的那段时间</span>, 对于提高程序性能至关重要.
</p>
</div>

<div id="outline-container-org14d88ef" class="outline-4">
<h4 id="org14d88ef"><span class="section-number-4">2.1.1.</span> 速度与吞吐量</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
根据本节的对比, 我们将会发现 CPU 的高速运算能力在等待数据传输的过程中无法充分发挥.
</p>
</div>

<ol class="org-ol">
<li><a id="org09217e5"></a>CPU 性能<br />
<div class="outline-text-5" id="text-2-1-1-1">
<p>
现代 CPU 由于其复杂的内部结构 (e.g., 多级缓存, 多核处理器, 和超线程技术), 在处理​<i>计算密集型任务</i>​时表现出色.
一些常见的 CPU 操作 (e.g., 整数加法 和 浮点运算) 的执行时间通常在几个纳秒到几十个纳秒之间<sup><a id="fnr.2" class="footref" href="#fn.2" role="doc-backlink">2</a></sup>.
这意味着 CPU 可以在一秒内执行数十亿次这类操作.
</p>

<p>
CPU 的数据吞吐量指的是在单位时间内能处理的数据量, 这个指标受多种因素影响, 包括 CPU 的核心数, 缓存大小, 以及内存带宽等.
随着 DDR4 和 DDR5 等新一代内存技术的推出, 内存带宽得到了显著提升: DDR4 内存的数据传输速率可达到 \( 21.3 \text{GB/s} \), 而 DDR5 则有望达到 \( 51.2 \text{GB/s} \).
如果磁盘等外设的数据传输速率过低, 则会导致程序中的线程产生大量的空闲时间.
</p>
</div>
</li>

<li><a id="org0f63d2b"></a>磁盘性能<br />
<div class="outline-text-5" id="text-2-1-1-2">
<p>
磁盘 I​/​O 操作的速度远低于 CPU.
其读写速度受到磁盘类型 (e.g., HDD, SSD), 接口 (e.g., SATA, NVMe), 和文件系统等因素的影响.
一般的 HDD 的顺序读写速度约为 \( 100-200 \text{MB/s} \); 高性能 SSD 普遍可以达到 \( 500 \text{MB/s} + \) 的速度.  <sup><a id="fnr.3" class="footref" href="#fn.3" role="doc-backlink">3</a></sup>
</p>

<p>
磁盘的吞吐量是衡量 I​/​O 性能的另一个重要指标.
磁盘读写操作涉及到机械移动 (在 HDD 中) 或电子切换 (在 SSD 中), 因此它们的响应时间通常以毫秒计算, 与 CPU 操作的纳秒级响应时间相差至少 \(3\) 个数量级.
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org594fe67" class="outline-4">
<h4 id="org594fe67"><span class="section-number-4">2.1.2.</span> 并行处理能力</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
现代 CPU 通过多核设计实现了并行处理能力.
此外, 超线程技术 (Hyper-Threading) 使得​<b>单个核心能够同时执行多个线程</b>, 进一步提高了处理效率.
</p>

<p>
传统的 HDD 由于其物理结构限制, 读写头在执行一个操作时, 进行另一个操作需要重新定位, 只能并发地处理并行 I​/​O 请求, 这会产生极大的延迟.
SSD 使用闪存单元来存储数据, RAID 通过将多个硬盘组合起来, 它们都可以真正地并行处理多个数据请求.
</p>

<p>
然而, 虽然 SSD 和 RAID 拥有真正并行处理的能力, 仍不能与 CPU 相比.
</p>
</div>
</div>
</div>

<div id="outline-container-orgcb46b9d" class="outline-3">
<h3 id="orgcb46b9d"><span class="section-number-3">2.2.</span> OpenMP 多线程机制</h3>
<div class="outline-text-3" id="text-2-2">
<p>
通过<a href="#orgfcf414e">上一节</a>的对比, 理论上<a href="#org9621aa6">经验法则</a>是合理的.
然而, 过多的线程可能导致线程上下文切换的开销增加, 从而降低总体性能.
</p>
</div>

<div id="outline-container-orgf10dc5d" class="outline-4">
<h4 id="orgf10dc5d"><span class="section-number-4">2.2.1.</span> 并行模式</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
根据相关文章<sup><a id="fnr.4" class="footref" href="#fn.4" role="doc-backlink">4</a></sup>:
</p>

<blockquote>
<p>
OpenMP 采用 fork-join 的方式进行并行运算:
</p>

<pre class="example" id="orgd64e6f8">
             __    __
            / _ 并 _ \
           / /      \ \
------&gt; FORK -- 行 -- JOIN --&gt;
主线程     \ \_    _/ /
            \__ 域 __/
</pre>

<p>
在这个模型中, 一开始只有一个主线程, 然后主线程遇到相关的命令就会创建多个线程.
</p>
</blockquote>

<p>
我们关注影响性能的两点:
</p>

<ul class="org-ul">
<li>当程序处于 FORK​/​JOIN 阶段时, 会创建​/​销毁多个线程.
创建时需要申请内存资源, 释放时有可能需要整理内存碎片, 这些都耗时较久.
后文在实验时, 将计时置于并行域之内, 以排除该干扰项.</li>
<li>机器上存在的线程数几乎必然大于 CPU 的核心数.
当单颗核心切换线程时, 会产生极大的开销.
它不是干扰项, 因为线程切换是不可避免的, 而本实验主要目的之一, 就是考察如何权衡 多线程处理的优势 和 线程切换的开销.</li>
</ul>
</div>
</div>

<div id="outline-container-orga520f70" class="outline-4">
<h4 id="orga520f70"><span class="section-number-4">2.2.2.</span> 编程模型</h4>
<div class="outline-text-4" id="text-2-2-2">
<div class="org-src-container">
<pre class="src src-C++"><span style="color: #a0132f;">#include</span> <span style="color: #000000;">&lt;</span><span style="color: #2544bb;">omp.h</span><span style="color: #000000;">&gt;</span>
<span style="color: #005a5f;">int</span> <span style="color: #721045;">main</span><span style="color: #000000;">()</span> <span style="color: #000000;">{</span>
<span style="color: #a0132f;">#pragma</span> omp DIRECTIVE <span style="color: #a8007f;">[</span>CLAUSE <span style="color: #005f88;">[</span><span style="color: #904200;">[</span>, <span style="color: #904200;">]</span> CLAUSE<span style="color: #005f88;">]</span> ...<span style="color: #a8007f;">]</span>
    <span style="color: #a8007f;">{</span>
        <span style="color: #505050;">// </span><span style="color: #505050;">&#24182;&#34892;&#22495;</span>
    <span style="color: #a8007f;">}</span>
<span style="color: #000000;">}</span>
</pre>
</div>
</div>
</div>
</div>
</div>

<div id="outline-container-org9afa006" class="outline-2">
<h2 id="org9afa006"><span class="section-number-2">3.</span> 实验设计与结果</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgf84db9f" class="outline-3">
<h3 id="orgf84db9f"><span class="section-number-3">3.1.</span> 环境配置</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>CPU 核心数: \( 5 \)</li>
<li>Fedora GNU​/​Linux</li>
<li>GCC 13.2.1</li>
<li>OpenMP 4.5</li>
</ul>
</div>
</div>

<div id="outline-container-orgf02037b" class="outline-3">
<h3 id="orgf02037b"><span class="section-number-3">3.2.</span> 设计思路</h3>
<div class="outline-text-3" id="text-3-2">
<ol class="org-ol">
<li>执行 <code>sudo bash -c 'echo 3 &gt; /proc/sys/vm/drop_caches'</code> 以清理 Linux 针对文件系统提供的 buffer.</li>
<li>向磁盘并行地写入 <code>MY_NUM_FILES</code> 个小文件.</li>
<li>清理 buffer; 从磁盘并行地读入 <code>MY_NUM_FILES</code> 个小文件</li>
<li>清理 buffer; 从磁盘并行地读入 0.5x​<code>MY_NUM_FILES</code> 个小文件, 同时并行地写入 0.5x​<code>MY_NUM_FILES</code> 个小文件.</li>
</ol>

<p>
实验为了模拟 GNU make 的行为, 设置了 <code>MY_AMOUNT_CALC</code> 以控制计算量大小.
该变量的值越大, 每个线程在打开文件之后执行的运算量越大.
</p>

<pre class="example" id="org3490f17">
./
 |__ Num_Threads_IO_Intensive.{org,html,pdf}  (one of which is this file)
 |
 |__ GNUmakefile  (testing interface)
 |
 |__ a.cpp  (source file)
</pre>

<p>
在当前目录调用
</p>
<pre class="example">
make
</pre>

<p>
或
</p>
<pre class="example">
make test
</pre>

<p>
会输出测试结果, 伴随一个用于读写小文件的文件夹 <code>./test/</code>.
执行
</p>
<pre class="example">
make clean
</pre>

<p>
以恢复目录结构到初始状态.
</p>
</div>
</div>

<div id="outline-container-org5206c17" class="outline-3">
<h3 id="org5206c17"><span class="section-number-3">3.3.</span> 代码</h3>
<div class="outline-text-3" id="text-3-3">
<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">&#20195;&#30721;1&nbsp; </span><code>./GNUmakefile</code></label><pre class="src src-makefile-gmake"><span style="color: #721045;">.SILENT</span>:

<span style="color: #721045;">.PHONY</span>: test
<span style="color: #721045;">test</span>: test/ test/a.exe
    echo    Num-Threads O-Time-per-File I-Time  IO-Time
    cd test/ ; for num_threads in <span style="color: #2544bb;">`seq 1 ${</span><span style="color: #00538b;">MY_NUM_THREADS</span><span style="color: #2544bb;">}`</span>; do  \
                 echo -n $$num_threads <span style="color: #2544bb;">' '</span> ;  \
                 for io_stat in <span style="color: #000000;">{</span>0..2<span style="color: #000000;">}</span>; do  \
                   echo 3 &gt; /proc/sys/vm/drop_caches ;  \
                   <span style="color: #00538b;">OMP_NUM_THREADS</span>=$$num_threads  \
                     ./a.exe $$io_stat $$MY_NUM_FILES $$MY_AMOUNT_CALC;  \
                   echo -n <span style="color: #2544bb;">' '</span> ;  \
                 done ;  \
                 echo ;  \
               done

<span style="color: #721045;">test/</span> :
    mkdir --parents  test/

<span style="color: #721045;">test/a.exe</span> : a.cpp test/
    g++ -std=c++20 -O0 -Wall  \
        -fopenmp  \
        -o test/a.exe  \
        a.cpp

<span style="color: #721045;">.PHONY</span>: clean
<span style="color: #721045;">clean</span>:
    rm --recursive --force  test/
    rm --force  --  *~  *\#*\#

<span style="color: #505050;"># </span><span style="color: #505050;">Local Variables&#58;</span>
<span style="color: #505050;"># </span><span style="color: #505050;">indent-tabs-mode: t</span>
<span style="color: #505050;"># </span><span style="color: #505050;">tab-width: 4</span>
<span style="color: #505050;"># </span><span style="color: #505050;">End:</span>
</pre>
</div>

<div class="org-src-container">
<label class="org-src-name"><span class="listing-number">&#20195;&#30721;2&nbsp; </span><code>./a.cpp</code></label><pre class="src src-C++"><span style="color: #a0132f;">#include</span> <span style="color: #000000;">&lt;</span><span style="color: #2544bb;">chrono</span><span style="color: #000000;">&gt;</span>
<span style="color: #a0132f;">#include</span> <span style="color: #000000;">&lt;</span><span style="color: #2544bb;">cstdlib</span><span style="color: #000000;">&gt;</span>
<span style="color: #a0132f;">#include</span> <span style="color: #000000;">&lt;</span><span style="color: #2544bb;">fstream</span><span style="color: #000000;">&gt;</span>
<span style="color: #a0132f;">#include</span> <span style="color: #000000;">&lt;</span><span style="color: #2544bb;">iostream</span><span style="color: #000000;">&gt;</span>
<span style="color: #a0132f;">#include</span> <span style="color: #000000;">&lt;</span><span style="color: #2544bb;">ratio</span><span style="color: #000000;">&gt;</span>
<span style="color: #a0132f;">#include</span> <span style="color: #000000;">&lt;</span><span style="color: #2544bb;">string</span><span style="color: #000000;">&gt;</span>
<span style="color: #a0132f;">#include</span> <span style="color: #000000;">&lt;</span><span style="color: #2544bb;">omp.h</span><span style="color: #000000;">&gt;</span>

<span style="color: #5317ac;">static</span> <span style="color: #005a5f;">int</span> <span style="color: #00538b;">num_files</span>, <span style="color: #00538b;">amount_calculation</span>;

<span style="color: #5317ac;">auto</span> <span style="color: #721045;">test_o</span><span style="color: #000000;">()</span> -&gt; <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">chrono</span>::<span style="color: #005a5f;">duration</span><span style="color: #000000;">&lt;</span><span style="color: #005a5f;">double</span>, <span style="color: #0000c0;">std</span>::<span style="color: #00538b;">micro</span><span style="color: #000000;">&gt;</span> <span style="color: #000000;">{</span>
    <span style="color: #5317ac;">decltype</span><span style="color: #a8007f;">(</span><span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">chrono</span>::<span style="color: #0000c0;">high_resolution_clock</span>::now<span style="color: #005f88;">()</span><span style="color: #a8007f;">)</span> <span style="color: #00538b;">start</span>, <span style="color: #00538b;">end</span>;

<span style="color: #a0132f;">#pragma</span> omp parallel
    <span style="color: #a8007f;">{</span>
<span style="color: #a0132f;">#pragma</span> omp single
        start = <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">chrono</span>::<span style="color: #0000c0;">high_resolution_clock</span>::now<span style="color: #005f88;">()</span>;

<span style="color: #a0132f;">#pragma</span> omp <span style="color: #5317ac;">for</span>
        <span style="color: #5317ac;">for</span> <span style="color: #005f88;">(</span><span style="color: #005a5f;">int</span> <span style="color: #00538b;">i</span> = 0; i &lt; num_files; ++i<span style="color: #005f88;">)</span> <span style="color: #005f88;">{</span>
            <span style="color: #0000c0;">std</span>::<span style="color: #005a5f;">ofstream</span> <span style="color: #00538b;">ofile</span><span style="color: #904200;">{</span><span style="color: #0000c0;">std</span>::to_string<span style="color: #7f10d0;">(</span>i<span style="color: #7f10d0;">)</span> + <span style="color: #2544bb;">".txt"</span>,
                                <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">ios_base</span>::out
                                | <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">ios_base</span>::trunc<span style="color: #904200;">}</span>;
            <span style="color: #5317ac;">while</span> <span style="color: #904200;">(</span><span style="color: #0000c0;">std</span>::rand<span style="color: #7f10d0;">()</span> % amount_calculation != 0<span style="color: #904200;">)</span>
                ofile &lt;&lt; <span style="color: #0000c0;">std</span>::rand<span style="color: #904200;">()</span>;
        <span style="color: #005f88;">}</span>

<span style="color: #a0132f;">#pragma</span> omp single
        end = <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">chrono</span>::<span style="color: #0000c0;">high_resolution_clock</span>::now<span style="color: #005f88;">()</span>;
    <span style="color: #a8007f;">}</span>

    <span style="color: #5317ac;">return</span> end - start;
<span style="color: #000000;">}</span>

<span style="color: #5317ac;">auto</span> <span style="color: #721045;">test_io</span><span style="color: #000000;">()</span> -&gt; <span style="color: #5317ac;">decltype</span><span style="color: #000000;">(</span>test_o<span style="color: #a8007f;">()</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
    <span style="color: #5317ac;">decltype</span><span style="color: #a8007f;">(</span><span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">chrono</span>::<span style="color: #0000c0;">high_resolution_clock</span>::now<span style="color: #005f88;">()</span><span style="color: #a8007f;">)</span> <span style="color: #00538b;">start</span>, <span style="color: #00538b;">end</span>;

<span style="color: #a0132f;">#pragma</span> omp parallel
    <span style="color: #a8007f;">{</span>
<span style="color: #a0132f;">#pragma</span> omp single
        start = <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">chrono</span>::<span style="color: #0000c0;">high_resolution_clock</span>::now<span style="color: #005f88;">()</span>;

<span style="color: #a0132f;">#pragma</span> omp <span style="color: #5317ac;">for</span>
        <span style="color: #5317ac;">for</span> <span style="color: #005f88;">(</span><span style="color: #005a5f;">int</span> <span style="color: #00538b;">i</span> = 0; i &lt; num_files; ++i<span style="color: #005f88;">)</span>
            <span style="color: #5317ac;">if</span> <span style="color: #005f88;">(</span><span style="color: #0000c0;">std</span>::<span style="color: #005a5f;">fstream</span> <span style="color: #00538b;">file</span><span style="color: #904200;">{</span><span style="color: #0000c0;">std</span>::to_string<span style="color: #7f10d0;">(</span>i<span style="color: #7f10d0;">)</span> + <span style="color: #2544bb;">".txt"</span>,
                                  <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">ios_base</span>::in
                                  | <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">ios_base</span>::out<span style="color: #904200;">}</span>; i % 2 == 0<span style="color: #005f88;">)</span>
                <span style="color: #5317ac;">while</span> <span style="color: #005f88;">(</span><span style="color: #0000c0;">std</span>::rand<span style="color: #904200;">()</span> % amount_calculation != 0<span style="color: #005f88;">)</span>
                    file &lt;&lt; <span style="color: #0000c0;">std</span>::rand<span style="color: #005f88;">()</span>;
            <span style="color: #5317ac;">else</span>
                <span style="color: #5317ac;">for</span> <span style="color: #005f88;">(</span><span style="color: #005a5f;">char</span> <span style="color: #00538b;">tmp</span>; <span style="color: #0000c0;">std</span>::rand<span style="color: #904200;">()</span> % amount_calculation != 0; <span style="color: #005f88;">)</span>
                    file &gt;&gt; tmp;

<span style="color: #a0132f;">#pragma</span> omp single
        end = <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">chrono</span>::<span style="color: #0000c0;">high_resolution_clock</span>::now<span style="color: #005f88;">()</span>;
    <span style="color: #a8007f;">}</span>

    <span style="color: #5317ac;">return</span> end - start;
<span style="color: #000000;">}</span>

<span style="color: #5317ac;">auto</span> <span style="color: #721045;">test_i</span><span style="color: #000000;">()</span> -&gt; <span style="color: #5317ac;">decltype</span><span style="color: #000000;">(</span>test_o<span style="color: #a8007f;">()</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
    <span style="color: #5317ac;">decltype</span><span style="color: #a8007f;">(</span><span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">chrono</span>::<span style="color: #0000c0;">high_resolution_clock</span>::now<span style="color: #005f88;">()</span><span style="color: #a8007f;">)</span> <span style="color: #00538b;">start</span>, <span style="color: #00538b;">end</span>;

<span style="color: #a0132f;">#pragma</span> omp parallel
    <span style="color: #a8007f;">{</span>
<span style="color: #a0132f;">#pragma</span> omp single
        start = <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">chrono</span>::<span style="color: #0000c0;">high_resolution_clock</span>::now<span style="color: #005f88;">()</span>;

<span style="color: #a0132f;">#pragma</span> omp <span style="color: #5317ac;">for</span>
        <span style="color: #5317ac;">for</span> <span style="color: #005f88;">(</span><span style="color: #005a5f;">int</span> <span style="color: #00538b;">i</span> = 0; i &lt; num_files; ++i<span style="color: #005f88;">)</span> <span style="color: #005f88;">{</span>
            <span style="color: #0000c0;">std</span>::<span style="color: #005a5f;">ifstream</span> <span style="color: #00538b;">ifile</span><span style="color: #904200;">{</span><span style="color: #0000c0;">std</span>::to_string<span style="color: #7f10d0;">(</span>i<span style="color: #7f10d0;">)</span> + <span style="color: #2544bb;">".txt"</span>,
                                <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">ios_base</span>::in<span style="color: #904200;">}</span>;
            <span style="color: #5317ac;">for</span> <span style="color: #904200;">(</span><span style="color: #005a5f;">char</span> <span style="color: #00538b;">tmp</span>; <span style="color: #0000c0;">std</span>::rand<span style="color: #7f10d0;">()</span> % amount_calculation != 0; <span style="color: #904200;">)</span>
                ifile &gt;&gt; tmp;
        <span style="color: #005f88;">}</span>

<span style="color: #a0132f;">#pragma</span> omp single
        end = <span style="color: #0000c0;">std</span>::<span style="color: #0000c0;">chrono</span>::<span style="color: #0000c0;">high_resolution_clock</span>::now<span style="color: #005f88;">()</span>;
    <span style="color: #a8007f;">}</span>

    <span style="color: #5317ac;">return</span> end - start;
<span style="color: #000000;">}</span>

<span style="color: #005a5f;">int</span> <span style="color: #721045;">main</span><span style="color: #000000;">(</span><span style="color: #005a5f;">int</span> <span style="color: #00538b;">argc</span>, <span style="color: #005a5f;">char</span> *<span style="color: #00538b;">argv</span><span style="color: #a8007f;">[]</span><span style="color: #000000;">)</span> <span style="color: #000000;">{</span>
    num_files = <span style="color: #0000c0;">std</span>::stoi<span style="color: #a8007f;">(</span>argv<span style="color: #005f88;">[</span>2<span style="color: #005f88;">]</span><span style="color: #a8007f;">)</span>,
      amount_calculation = <span style="color: #0000c0;">std</span>::stoi<span style="color: #a8007f;">(</span>argv<span style="color: #005f88;">[</span>3<span style="color: #005f88;">]</span><span style="color: #a8007f;">)</span>;

    <span style="color: #5317ac;">decltype</span><span style="color: #a8007f;">(</span>test_o<span style="color: #005f88;">()</span><span style="color: #a8007f;">)</span> <span style="color: #00538b;">time_elapsed</span>;

    <span style="color: #5317ac;">switch</span> <span style="color: #a8007f;">(</span><span style="color: #0000c0;">std</span>::stoi<span style="color: #005f88;">(</span>argv<span style="color: #904200;">[</span>1<span style="color: #904200;">]</span><span style="color: #005f88;">)</span><span style="color: #a8007f;">)</span> <span style="color: #a8007f;">{</span>
        <span style="color: #5317ac;">case</span> 0:
            time_elapsed = test_o<span style="color: #005f88;">()</span>;
            <span style="color: #5317ac;">break</span>;
        <span style="color: #5317ac;">case</span> 1:
            time_elapsed = test_i<span style="color: #005f88;">()</span>;
            <span style="color: #5317ac;">break</span>;
        <span style="color: #5317ac;">case</span> 2:
            time_elapsed = test_io<span style="color: #005f88;">()</span>;
            <span style="color: #5317ac;">break</span>;
    <span style="color: #a8007f;">}</span>

    <span style="color: #0000c0;">std</span>::cout &lt;&lt; time_elapsed / num_files;
<span style="color: #000000;">}</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc584ec8" class="outline-3">
<h3 id="orgc584ec8"><span class="section-number-3">3.4.</span> 测试</h3>
<div class="outline-text-3" id="text-3-4">
<div class="org-src-container">
<pre class="src src-bash"><span style="color: #00538b;">MY_NUM_THREADS</span>=9  <span style="color: #2544bb;">\</span>
<span style="color: #00538b;">MY_NUM_FILES</span>=10000  <span style="color: #2544bb;">\</span>
<span style="color: #00538b;">MY_AMOUNT_CALC</span>=100  <span style="color: #2544bb;">\</span>
make
make clean
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<tbody>
<tr>
<td class="org-right">Num-Threads</td>
<td class="org-left">O-Time-per-File</td>
<td class="org-left">I-Time</td>
<td class="org-left">IO-Time</td>
</tr>

<tr>
<td class="org-right">1</td>
<td class="org-left">99.5324us</td>
<td class="org-left">72.9784us</td>
<td class="org-left">80.1102us</td>
</tr>

<tr>
<td class="org-right">2</td>
<td class="org-left">53.3164us</td>
<td class="org-left">38.1627us</td>
<td class="org-left">46.0702us</td>
</tr>

<tr>
<td class="org-right">3</td>
<td class="org-left">38.7215us</td>
<td class="org-left">28.9921us</td>
<td class="org-left">33.8469us</td>
</tr>

<tr>
<td class="org-right">4</td>
<td class="org-left">31.8808us</td>
<td class="org-left">23.2954us</td>
<td class="org-left">27.3944us</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-left">27.3368us</td>
<td class="org-left">20.6604us</td>
<td class="org-left">23.5418us</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-left">25.8475us</td>
<td class="org-left">17.8479us</td>
<td class="org-left">21.0984us</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-left">24.3816us</td>
<td class="org-left">18.7930us</td>
<td class="org-left">21.2713us</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-left">27.5352us</td>
<td class="org-left">20.1203us</td>
<td class="org-left">22.1087us</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-left">35.6278us</td>
<td class="org-left">25.3981us</td>
<td class="org-left">26.3765us</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>

<div id="outline-container-org0a70bea" class="outline-2">
<h2 id="org0a70bea"><span class="section-number-2">4.</span> 数据分析</h2>
<div class="outline-text-2" id="text-4">
<p>
第<a href="#orgc584ec8">3.4</a>节中的测试结果为多次实验的中位数.
其中的每一行以 <code>线程数 平均写时间 平均读时间 平均读写时间</code> 的形式展示了不同线程数下程序的耗时 (单位: 微秒).
</p>
</div>

<div id="outline-container-org6b472a6" class="outline-3">
<h3 id="org6b472a6"><span class="section-number-3">4.1.</span> 性能上升区间</h3>
<div class="outline-text-3" id="text-4-1">
<p>
当测试的线程数从 \( 1 \) 增加到 \( 5 \), 也就是 \[
\text{线程数} \le \text{核心数}
\] 时, 线程数越多, 耗时越短.
这符合可并行程序的一般执行情况: 既然任务是可并行的, 那么就可以在合理范围内增加线程数以提高并行任务数, 缩短执行时间.
</p>

<p>
但是我们看到, 更多的线程数带来的增益是越来越少的.
E.g., \( T_{\text{num_threads}=2} \gt \frac12 \cdot T_{\text{num_threads}=1} \), \( T_{\text{num_threads}=3} \gt \frac23 \cdot T_{\text{num_threads}=2} \), etc.
推测这主要是因为性能瓶颈从 CPU 处理数据, 转到磁盘 I​/​O 上.
</p>

<p>
无论如何, 在这一区间, 线程数越多, 性能越好.
</p>
</div>
</div>

<div id="outline-container-org445d11a" class="outline-3">
<h3 id="org445d11a"><span class="section-number-3">4.2.</span> 最佳线程数</h3>
<div class="outline-text-3" id="text-4-2">
<p>
当 \[
\text{线程数} \gt \text{核心数}
\] 时, 性能提升只在线程数略高于核心数时出现.
</p>

<p>
根据多次测试的结果,
</p>
<ul class="org-ul">
<li>当线程数为 \( 6 \) 或 \( 7 \) 时, 性能比线程数为 \( 5 \)<sup><a id="fnr.5" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> 时更好, 但难以断定究竟是 \( 6 \) 更好还是 \( 7 \) 更好,</li>
<li>当线程数为 \( 8 \) 时, 与线程数为 \( 5 \)<sup><a id="fnr.5.100" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> 时对比, 时好时差.</li>
<li>当线程数为 \( 9 \) 时, 性能明显低于线程数为 \( 5 \)<sup><a id="fnr.5.100" class="footref" href="#fn.5" role="doc-backlink">5</a></sup> 的情形, 因此认为从这个数值开始, 逐渐远离峰值.</li>
</ul>

<p>
也即 \[
P_{\text{num_threads=5}} \lt P_{\text{num_threads=6}} \approx P_{\text{num_threads=7}} \gt P_{\text{num_threads=8}}
\].
</p>
</div>
</div>

<div id="outline-container-org1cb6cfd" class="outline-3">
<h3 id="org1cb6cfd"><span class="section-number-3">4.3.</span> 归因分析</h3>
<div class="outline-text-3" id="text-4-3">
<p>
线程数略高于核心数时, 程序能占满 CPU 的各核心; <br />
<span class="underline">当某线程在等待磁盘 I​/​O 时, 它会 <i>yield</i> 若干个时间片, 而如果此时程序有​<b>正在执行计算但却被挂起</b>​的线程, 那么它很可能会 <i>acquire</i> 这些时间片并继续执行.</span>
</p>

<p>
在 I​/​O 密集型任务中, 程序在 CPU 上的所有线程很可能都在等在磁盘 I​/​O, 此时如果能有一个线程充分利用这段时间执行计算, 必然能够提高性能.
</p>
</div>
</div>
</div>

<div id="outline-container-orgec29a4d" class="outline-2">
<h2 id="orgec29a4d"><span class="section-number-2">5.</span> 结论与建议</h2>
<div class="outline-text-2" id="text-5">
<p>
根据第<a href="#org445d11a">4.2</a>节的趋势分析, 线程数略高于核心数时就是性能峰值.
保守起见, 本文建议使用 \( \text{核心数} + 1 \).
</p>

<p>
在 GNU​/​Linux 上, 使用
</p>

<div class="org-src-container">
<pre class="src src-bash">$ make -j$<span style="color: #000000;">(</span><span style="color: #a8007f;">(</span><span style="color: #8f0075;">`nproc`</span>+1<span style="color: #a8007f;">)</span><span style="color: #000000;">)</span>
</pre>
</div>

<p>
即可.
</p>
</div>

<div id="outline-container-orgbc6c438" class="outline-3">
<h3 id="orgbc6c438"><span class="section-number-3">5.1.</span> 经验法则的适用性</h3>
<div class="outline-text-3" id="text-5-1">
<p>
本文讨论的是可并行化的程序, 这适用于绝大多数的 <code>Makefile</code>.
但是, 如果程序本身就不可并行 (e.g., 根据 <code>Makefile</code> 中的 <i>recipe</i>​s 对 <i>target</i>​s 进行​拓扑排序, 如果排序结果是唯一的), 那么它等同于串行执行.
</p>

<p>
如果程序不是 I​/​O 密集型的, 那么性能瓶颈很可能也在磁盘这边, 则<a href="#org9621aa6">该经验法则</a>也就无法提供可观的收益.
</p>
</div>
</div>

<div id="outline-container-org3dfefbb" class="outline-3">
<h3 id="org3dfefbb"><span class="section-number-3">5.2.</span> 实验的局限性</h3>
<div class="outline-text-3" id="text-5-2">
<p>
本实验采用了低性能的 HDD 而不是高性能的 SSD, 放大了 CPU 性能与磁盘 I​/​O 之间的差距, 从而提高了增加线程数目带来的性能增益.
实验中关闭了 Linux 针对文件系统提供的 buffer, 在实际应用中很少会这么做.
</p>

<p>
因此, 如果您的机器不存在上述情况, 那么结果可能有所不同.
</p>
</div>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">&#33050;&#27880;: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1" role="doc-backlink">1</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://www.flossmanuals.net">FLOSS Manuals</a> &amp; <a href="https://www.fsf.org">the FSF</a>: <a href="https://archive.flossmanuals.net/command-line/installing-software.html">Compile the software</a></p></div></div>

<div class="footdef"><sup><a id="fn.2" class="footnum" href="#fnr.2" role="doc-backlink">2</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><i>Agner Fog</i>: <a href="https://www.agner.org/optimize/instruction_tables.pdf">Instruction Tables</a>, 2023</p></div></div>

<div class="footdef"><sup><a id="fn.3" class="footnum" href="#fnr.3" role="doc-backlink">3</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://storagereview.com">StorageReview</a>: <a href="https://www.storagereview.com/ssd-vs-hdd">SSD vs HDD</a></p></div></div>

<div class="footdef"><sup><a id="fn.4" class="footnum" href="#fnr.4" role="doc-backlink">4</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara"><a href="https://github.com/shynur"><code>shynur</code></a>: <a href="https://shynur.github.io/CheatSheets/OpenMP">简明 OpenMP: C/C++ 并行计算</a></p></div></div>

<div class="footdef"><sup><a id="fn.5" class="footnum" href="#fnr.5" role="doc-backlink">5</a></sup> <div class="footpara" role="doc-footnote"><p class="footpara">核心数.</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="author">&#20316;&#32773;: <a href="https://github.com/shynur"><i>谢骐</i></a></p>
<p class="date">Created: 2023-12-16 周六 21:41</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>